/*

15의 배수는 3의 배수이면서 5의 배수이어야 한다. 즉, 각 자리 수의 합이 3의 배수이고 일의 자리가 5, 0을 만족해야 한다.
해당 문제에서는 1과 5만을 가지고 숫자를 만들어야 하므로 일의 자리는 5로 고정 되어 있음을 알 수 있다.

dp[0][i] : 길이가 i인 숫자 중 15의 배수의 개수.
dp[1][i] : 길이가 i인 숫자 중 15로 나누었을 때 나머지가 5인 개수
dp[2][i] : 길이가 i인 숫자 중 15로 나누었을 때 나머지가 10인 개수

다음 step으로 진행하기 위해 앞 자리에 1, 5를 추가하는 경우를 생각할 수 있다.

1. 앞 자리에 1을 추가할 경우
: 이전 숫자의 길이가 n-1이라고 할 때, 10^n을 더해주는 것과 같다. 나머지가 10이 증가하게 된다.
  이전 숫자를 15로 나누었을 때 나머지가 5라면 앞자리에 1을 추가할 경우 현재 숫자는 15의 배수가 된다.
  예를 들어, 현재 숫자가 515일 경우 (515 % 15 == 5) 앞에 1을 추가할 경우 (1515 % 15 == 0)

2. 앞 자리에 5를 추가할 경우
: 현재 숫자를 15로 나눈 나머지 = 이전 숫자를 15로 나눈 나머지 + 5

*/
#include<bits/stdc++.h>
using namespace std;

int dp[3][1516];

int main() {
	int N;
	cin >> N;
	dp[0][2] = 1; // 15 : 15의 배수
	dp[2][2] = 1; // 55 : 15로 나누었을 때 나머지가 10

	for (int i = 3; i <= N; i++) {

		// 15의 배수 찾기
		// 이전 자리수에서 나머지가 5인 수의 개수(앞 자리에 1을 붙이면 현재 자리수에서 15의 배수가 된다.)
		//  + 이전 자리수에서 나머지가 10인 수의 개수(앞 자리에 5를 붙이면 현재 자리수에서 15의 배수가 된다.)
		dp[0][i] = (dp[1][i - 1] + dp[2][i - 1]) % 1000000007;

		// 15로 나누었을 때 나머지가 5인 수 찾기
		// 이전 자리수에서 나머지가 0인 수의 개수(앞 자리에 5를 붙이면 현재 자리수에서 15로 나누었을 때 나머지가 5가 된다.)
		// + 이전 자리수에서 나머지가 10인 수의 개수(앞 자리에 1을 붙이면 현재 자리수에서 15로 나누었을 때 나머지가 5가 된다.)
		dp[1][i] = (dp[0][i - 1] + dp[2][i - 1]) % 1000000007;

		// 15로 나누었을 때 나머지가 10인 수 찾기
		// 이전 자리수에서 나머지가 0인 수의 개수(앞 자리에 1을 붙이면 현재 자리수에서 15로 나누었을 때 나머지가 10이 된다.)
		// + 이전 자리수에서 나머지가 5인 수의 개수(앞 자리에 5를 붙이면 현재 자리수에서 15로 나누었을 때 나머지가 10이 된다.)
		dp[2][i] = (dp[0][i - 1] + dp[1][i - 1]) % 1000000007;

	}
	cout << dp[0][N] << '\n';

	return 0;
}
